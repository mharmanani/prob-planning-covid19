domain covid_planner {

	types {
        mandate_status: object;
        person: object;
        direction : {@up, @down, @left, @right, @none};
        floor: object;
        wall: object;
        x_pos: int;
        y_pos: int;
	};

    pvariables {

        // Action costs and penalties
		COST_MASK              : {non-fluent, real, default = -1 }; 
        COST_VACCINE           : {non-fluent, real, default = -5 }; 
        COST_ISOLATION         : {non-fluent, real, default = -100 }; 
		PENALTY_INFECTED       : {non-fluent, real, default = -1 };  
		PENALTY_DEATH          : {non-fluent, real, default = -8 };

        GRID-SIZE-X : { non-fluent, int, default = 4 };
		GRID-SIZE-Y : { non-fluent, int, default = 4 };
        POPULATION  : { non-fluent, int, default = 5 }; 
        
        K     : {non-fluent, real, default =   1 };
        L     : {non-fluent, real, default =   1 };
        BETA  : {non-fluent, real, default =   1 };
        SIGMA : {non-fluent, real, default =   1 };
        GAMMA : {non-fluent, real, default =   1 }; 

        MASK_SELF_PROT_FACTOR : {non-fluent, real, default =   0.80 }; 
        MASK_OTHR_PROT_FACTOR : {non-fluent, real, default =   0.60 }; 
        VACCINE_PROT_FACTOR   : {non-fluent, real, default =   0.13 }; 
        NAT_IMM_PROT_FACTOR   : {non-fluent, real, default =   0.30 }; 
        PROB_MASK_COMPLIANCE  : {non-fluent, real, default =   0.96 };
        PROB_VAX_COMPLIANCE   : {non-fluent, real, default =   0.93 };

        WALL(x_pos, y_pos)  : {non-fluent, bool, default = false }; 
        FLOOR(x_pos, y_pos) : {non-fluent, bool, default = false }; 

        //coordinates of the people
		xPos(person) : { state-fluent, int, default = 0};
		yPos(person) : { state-fluent, int, default = 0};
        
        // intervention outcomes
        masked(person)   : { state-fluent, bool, default = false};
        vaxxed(person)   : { state-fluent, bool, default = false};

        // Intermediate fluents: next x and y of people
		nextXPos(person) : { interm-fluent, int, level = 4 };
		nextYPos(person) : { interm-fluent, int, level = 4 };

        //the walk action, takes a person argument and is set to a direction value
		walk(person) : { action-fluent, direction, default = @none}; 

        //check if their step is out of bounds
		outBoundsNext(person) :   { interm-fluent, bool, level = 3 };
        moveOutcome(person)   : {interm-fluent, direction, level = 2};

        // Interventions
        mask(person)      : { action-fluent, bool, default = false};
        vaccinate(person) : { action-fluent, bool, default = false};

    }

    cpfs {

        // Count the number of infected neighbours 
        count_infected_neighbours(?p) = forall_{?p2 : person} [
            ((xPos(?p2) - xPos(?p) <= K) | (xPos(?p) - xPos(?p2) <= K)) 
            ^ ((yPos(?p2) - yPos(?p) <= K) | (yPos(?p) - yPos(?p2) <= K)) 
            ^ infected(?p2)
        ];

        // Count the number of infected + masked neighbours 
        count_masked_neighbours(?p) = forall_{?p2 : person} [
            ((xPos(?p2) - xPos(?p) <= K) | (xPos(?p) - xPos(?p2) <= K)) 
            ^ ((yPos(?p2) - yPos(?p) <= K) | (yPos(?p) - yPos(?p2) <= K)) 
            ^ infected(?p2) ^ masked(?p2);
        ];

        exposed'(?p) = if (count_infected_neighbours(?p) > 0) then [
            if (susceptible(?p) ^ (~masked(?p)) ^ (~vaxxed(?p)))
                then [Bernouilli(BETA/(4*K*L) 
                    * (count_infected_neighbours(?p) - MASK_OTHR_PROT_FACTOR*count_masked_neighbours(?p)))]
                else if (susceptible(?p) ^ (masked(?p)) ^ (~vaxxed(?p))) then
                    [Bernouilli(BETA/(4*K*L) * MASK_SELF_PROT_FACTOR * 
                    * (count_infected_neighbours(?p) - MASK_OTHR_PROT_FACTOR*count_masked_neighbours(?p)))]
                else if (susceptible(?p) ^ vaxxed(?p)) then
                    [Bernouilli(BETA/(4*K*L) * VACCINE_PROT_FACTOR * count_infected_neighbours(?p))]
                else if (recovered(?p)) then
                    [Bernouilli(BETA/(4*K*L) * NAT_IMM_PROT_FACTOR * count_infected_neighbours(?p))]];

        infected'(?p) = if (exposed(?p)) then [
            Bernouilli(SIGMA)
        ];

        recovered'(?p) = if (infected(?p))
            then Bernouilli(GAMMA);

        deceased'(?p) = if (infected(?p))
            then Bernouilli(1 - GAMMA);

        vaccinate(?p) = if (~vaccinated(?p)) 
            then Bernouilli(PROB_VAX_COMPLIANCE);

        mask(?p) = if (~masked(?p)) 
            then Bernouilli(PROB_MASK_COMPLIANCE);

        personMove(?p) = Discrete(direction,
						@left : 0.2,
						@right : 0.2,
						@up : 0.2,
						@down : 0.2,
						@none : 0.2
						);

        moveOutcome(?p) = personMove(?p);

        //check if a person is going outside the boundaries
		//note: could use a switch statement for enums in place of if-else here
		outBoundsNext(?p) = if(moveOutcome(?p) == @left) then (xPos(?p) - 1 < 0 | WALL(xPos(?p) - 1, yPos(?p)))
				    else if (moveOutcome(?p) == @right) then (xPos(?p) + 1 >= GRID-SIZE-X | WALL(xPos(?p) + 1, yPos(?p)))
				    else if (moveOutcome(?p) == @down) then (yPos(?p) - 1 < 0 | WALL(xPos(?p), yPos(?p) - 1))
				    else if (moveOutcome(?p) == @up) then (yPos(?p) + 1 >= GRID-SIZE-Y | WALL(xPos(?p), yPos(?p) + 1))
				    else false;

        //next x position of a person (unless they went  out of bounds, then it stays the same)
		nextXPos(?p) = if(~outBoundsNext(?p) ^ ~WALL(moveOutcome(?p)))
					then [if(moveOutcome(?p) == @left) 
						then xPos(?p) -1
						else if(moveOutcome(?p) == @right)
						then xPos(?p) +1
					      else xPos(?p)]
				else xPos(?p);

		//next y position of a person (unless they went  out of bounds, then it stays the same)
		nextYPos(?p) = if(~outBoundsNext(?p) ^ ~WALL(moveOutcome(?p)))
					then [if(moveOutcome(?p) == @down) 
						then yPos(?p) -1
						else if(moveOutcome(?p) == @up) 
						then yPos(?p) +1
					      else yPos(?p)]
				else yPos(?p);

        //update xpos unless there was a conflict (stays the same)
		xPos'(?p) = nextXPos(?p);

		//update ypos unless there was a conflict (stays the same)
		yPos'(?p) =  nextYPos(?p);
    };

    reward = 
        - [sum_{?p : person} [ infected(?p) ]]

    state-action-constraints {
        forall_{?p : person} [(xPos(?p) >= 0) ^ (yPos(?p) >=0) ^ (xPos(?p) < GRID-SIZE-X) ^ (yPos(?p) < GRID-SIZE-Y)];
    };
}